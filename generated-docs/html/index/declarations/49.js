// This file was generated by purescript-docs-search.
window.DocsSearchIndex["49"] = [["fail",[{"values":[{"sourceSpan":{"start":[168,1],"name":".spago/foreign/v5.0.0/src/Foreign.purs","end":[168,38]},"score":4,"packageInfo":{"values":["foreign"],"tag":"Package"},"name":"fail","moduleName":"Foreign","info":{"values":[{"type":{"tag":"ForAll","contents":["a",{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeConstructor","contents":[["Foreign"],"ForeignError"]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Foreign"],"F"]},{"tag":"TypeVar","contents":"a"}]}]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Throws a failure error in `F`.\n"}],"tag":"SearchResult"},{"values":[{"sourceSpan":null,"score":0,"packageInfo":{"values":[],"tag":"Builtin"},"name":"Fail","moduleName":"Prim.TypeError","info":{"values":[{"superclasses":[],"fundeps":[],"arguments":[["message",{"tag":"NamedKind","contents":[["Prim","TypeError"],"Doc"]}]]}],"tag":"TypeClassResult"},"hashAnchor":"t","comments":"The Fail type class is part of the custom type errors feature. To provide\na custom type error when someone tries to use a particular instance,\nwrite that instance out with a Fail constraint.\n\nFor more information, see\n[the Custom Type Errors guide](https://github.com/purescript/documentation/blob/master/guides/Custom-Type-Errors.md).\n"}],"tag":"SearchResult"}]],["failed",[{"values":[{"sourceSpan":null,"score":1,"packageInfo":{"values":["fork"],"tag":"Package"},"name":"Failed","moduleName":"Control.Monad.Fork.Class","info":{"values":[{"arguments":[{"tag":"TypeVar","contents":"e"}]}],"tag":"DataConstructorResult"},"hashAnchor":"v","comments":null}],"tag":"SearchResult"}]],["false",[{"values":[{"sourceSpan":null,"score":0,"packageInfo":{"values":[],"tag":"Builtin"},"name":"False","moduleName":"Prim.Boolean","info":{"values":[{"kind":{"tag":"NamedKind","contents":[["Prim","Boolean"],"Boolean"]}}],"tag":"ExternDataResult"},"hashAnchor":"t","comments":"The 'False' boolean type.\n"}],"tag":"SearchResult"}]],["fanin",[{"values":[{"sourceSpan":{"start":[74,1],"name":".spago/profunctor/v4.1.0/src/Data/Profunctor/Choice.purs","end":[80,22]},"score":2,"packageInfo":{"values":["profunctor"],"tag":"Package"},"name":"fanin","moduleName":"Data.Profunctor.Choice","info":{"values":[{"type":{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["p",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Control","Category"],"Category"],"constraintArgs":[{"tag":"TypeVar","contents":"p"}]},{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Profunctor","Choice"],"Choice"],"constraintArgs":[{"tag":"TypeVar","contents":"p"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"p"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"c"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"p"},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"p"},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Either"],"Either"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}}]},{"tag":"TypeVar","contents":"c"}]}]}]}]}]},null]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Compose a value which eliminates a sum from two values, each eliminating\none side of the sum.\n\nThis combinator is useful when assembling values from smaller components,\nbecause it provides a way to support two different types of input.\n\nSpecializing `(|||)` to function application would look like this:\n```\n(|||) :: forall a b c d. (a -> c) -> (b -> c) -> Either a b -> c\n```\nWe take two functions, `f` and `g`, which both return the same type `c` and we transform them into a\nsingle function which takes an `Either` value with the parameter type of `f` on the left side and\nthe parameter type of `g` on the right side. The function then runs either `f` or `g`, depending on\nwhether the `Either` value is a `Left` or a `Right`.\nThis allows us to bundle two different computations which both have the same result type into one\nfunction which will run the approriate computation based on the parameter supplied in the `Either` value.\n"}],"tag":"SearchResult"}]],["fanout",[{"values":[{"sourceSpan":{"start":[71,1],"name":".spago/profunctor/v4.1.0/src/Data/Profunctor/Strong.purs","end":[77,21]},"score":2,"packageInfo":{"values":["profunctor"],"tag":"Package"},"name":"fanout","moduleName":"Data.Profunctor.Strong","info":{"values":[{"type":{"tag":"ForAll","contents":["c",{"tag":"ForAll","contents":["b",{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["p",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Control","Category"],"Category"],"constraintArgs":[{"tag":"TypeVar","contents":"p"}]},{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Profunctor","Strong"],"Strong"],"constraintArgs":[{"tag":"TypeVar","contents":"p"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"p"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"b"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"p"},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"c"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeVar","contents":"p"},{"tag":"TypeVar","contents":"a"}]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Tuple"],"Tuple"]},{"tag":"TypeVar","contents":"b"}]},{"tag":"TypeVar","contents":"c"}]}}]}]}]}]}]},null]},null]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Compose a value which introduces a `Tuple` from two values, each introducing\none side of the `Tuple`.\n\nThis combinator is useful when assembling values from smaller components,\nbecause it provides a way to support two different types of output.\n\nSpecializing `(&&&)` to function application would look like this:\n```\n(&&&) :: forall a b c. (a -> b) -> (a -> c) -> (a -> (Tuple b c))\n```\nWe take two functions, `f` and `g`, with the same parameter type and we transform them into a\nsingle function which takes one parameter and returns a `Tuple` of the results of running\n`f` and `g` on the parameter, respectively.  This allows us to run two parallel computations\non the same input and return both results in a `Tuple`.\n"}],"tag":"SearchResult"}]],["cdatasectionnode",[{"values":[{"sourceSpan":null,"score":2,"packageInfo":{"values":["web-dom"],"tag":"Package"},"name":"CDATASectionNode","moduleName":"Web.DOM.NodeType","info":{"values":[{"arguments":[]}],"tag":"DataConstructorResult"},"hashAnchor":"v","comments":null}],"tag":"SearchResult"}]],["c2",[{"values":[{"sourceSpan":{"start":[21,1],"name":".spago/functors/v3.1.1/src/Data/Functor/Coproduct/Nested.purs","end":[21,28]},"score":2,"packageInfo":{"values":["functors"],"tag":"Package"},"name":"C2","moduleName":"Data.Functor.Coproduct.Nested","info":{"values":[{"type":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Data","Functor","Coproduct"],"Coproduct"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeVar","contents":"z"}]},"arguments":[["a",null],["z",null]]}],"tag":"TypeSynonymResult"},"hashAnchor":"t","comments":null}],"tag":"SearchResult"}]],["beforeinput",[{"values":[{"sourceSpan":{"start":[5,1],"name":".spago/web-uievents/v2.0.0/src/Web/UIEvent/InputEvent/EventTypes.purs","end":[5,25]},"score":2,"packageInfo":{"values":["web-uievents"],"tag":"Package"},"name":"beforeinput","moduleName":"Web.UIEvent.InputEvent.EventTypes","info":{"values":[{"type":{"tag":"TypeConstructor","contents":[["Web","Event","Event"],"EventType"]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":null}],"tag":"SearchResult"}]],["beforeprint",[{"values":[{"sourceSpan":{"start":[14,1],"name":".spago/web-html/v2.3.0/src/Web/HTML/Event/EventTypes.purs","end":[14,25]},"score":3,"packageInfo":{"values":["web-html"],"tag":"Package"},"name":"beforeprint","moduleName":"Web.HTML.Event.EventTypes","info":{"values":[{"type":{"tag":"TypeConstructor","contents":[["Web","Event","Event"],"EventType"]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":null}],"tag":"SearchResult"}]],["beforescriptexecute",[{"values":[{"sourceSpan":{"start":[17,1],"name":".spago/web-html/v2.3.0/src/Web/HTML/Event/EventTypes.purs","end":[17,33]},"score":3,"packageInfo":{"values":["web-html"],"tag":"Package"},"name":"beforescriptexecute","moduleName":"Web.HTML.Event.EventTypes","info":{"values":[{"type":{"tag":"TypeConstructor","contents":[["Web","Event","Event"],"EventType"]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":null}],"tag":"SearchResult"}]],["beforeunload",[{"values":[{"sourceSpan":{"start":[5,1],"name":".spago/web-html/v2.3.0/src/Web/HTML/Event/BeforeUnloadEvent/EventTypes.purs","end":[5,26]},"score":3,"packageInfo":{"values":["web-html"],"tag":"Package"},"name":"beforeunload","moduleName":"Web.HTML.Event.BeforeUnloadEvent.EventTypes","info":{"values":[{"type":{"tag":"TypeConstructor","contents":[["Web","Event","Event"],"EventType"]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":null}],"tag":"SearchResult"}]],["beforeunloadevent",[{"values":[{"sourceSpan":{"start":[11,1],"name":".spago/web-html/v2.3.0/src/Web/HTML/Event/BeforeUnloadEvent.purs","end":[11,46]},"score":3,"packageInfo":{"values":["web-html"],"tag":"Package"},"name":"BeforeUnloadEvent","moduleName":"Web.HTML.Event.BeforeUnloadEvent","info":{"values":[{"kind":{"tag":"NamedKind","contents":[["Prim"],"Type"]}}],"tag":"ExternDataResult"},"hashAnchor":"t","comments":null}],"tag":"SearchResult"}]],["beside",[{"values":[{"sourceSpan":null,"score":0,"packageInfo":{"values":[],"tag":"Builtin"},"name":"Beside","moduleName":"Prim.TypeError","info":{"values":[{"kind":{"tag":"FunKind","contents":[{"tag":"NamedKind","contents":[["Prim","TypeError"],"Doc"]},{"tag":"FunKind","contents":[{"tag":"NamedKind","contents":[["Prim","TypeError"],"Doc"]},{"tag":"NamedKind","contents":[["Prim","TypeError"],"Doc"]}]}]}}],"tag":"ExternDataResult"},"hashAnchor":"t","comments":"The Beside type constructor combines two Docs horizontally\nto be used in a custom type error.\n\nFor more information, see\n[the Custom Type Errors guide](https://github.com/purescript/documentation/blob/master/guides/Custom-Type-Errors.md).\n"}],"tag":"SearchResult"}]],["between",[{"values":[{"sourceSpan":{"start":[194,1],"name":".spago/prelude/v4.1.1/src/Data/Ord.purs","end":[194,53]},"score":47,"packageInfo":{"values":["prelude"],"tag":"Package"},"name":"between","moduleName":"Data.Ord","info":{"values":[{"type":{"tag":"ForAll","contents":["a",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Data","Ord"],"Ord"],"constraintArgs":[{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeVar","contents":"a"}]},{"tag":"TypeConstructor","contents":[["Prim"],"Boolean"]}]}]}]}]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Test whether a value is between a minimum and a maximum (inclusive).\nFor example:\n\n``` purescript\nlet f = between 0 10\nf 0    == true\nf (-5) == false\nf 5    == true\nf 10   == true\nf 15   == false\n```\n"}],"tag":"SearchResult"}]],["aff",[{"values":[{"sourceSpan":{"start":[64,1],"name":".spago/aff/v5.1.2/src/Effect/Aff.purs","end":[64,38]},"score":5,"packageInfo":{"values":["aff"],"tag":"Package"},"name":"Aff","moduleName":"Effect.Aff","info":{"values":[{"kind":{"tag":"FunKind","contents":[{"tag":"NamedKind","contents":[["Prim"],"Type"]},{"tag":"NamedKind","contents":[["Prim"],"Type"]}]}}],"tag":"ExternDataResult"},"hashAnchor":"t","comments":"An `Aff a` is an asynchronous computation with effects. The\ncomputation may either error with an exception, or produce a result of\ntype `a`. `Aff` effects are assembled from primitive `Effect` effects using\n`makeAff` or `liftEffect`.\n"}],"tag":"SearchResult"}]],["affeventsource",[{"values":[{"sourceSpan":{"start":[58,1],"name":".spago/halogen/v5.1.1/src/Halogen/Query/EventSource.purs","end":[62,21]},"score":0,"packageInfo":{"values":["halogen"],"tag":"Package"},"name":"affEventSource","moduleName":"Halogen.Query.EventSource","info":{"values":[{"type":{"tag":"ForAll","contents":["a",{"tag":"ForAll","contents":["m",{"tag":"ConstrainedType","contents":[{"constraintClass":[["Effect","Aff","Class"],"MonadAff"],"constraintArgs":[{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Prim"],"Function"]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Query","EventSource"],"Emitter"]},{"tag":"TypeConstructor","contents":[["Effect","Aff"],"Aff"]}]},{"tag":"TypeVar","contents":"a"}]}]},{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Effect","Aff"],"Aff"]},{"tag":"ParensInType","contents":{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Query","EventSource"],"Finalizer"]},{"tag":"TypeConstructor","contents":[["Effect","Aff"],"Aff"]}]}}]}]}}]},{"tag":"TypeApp","contents":[{"tag":"TypeApp","contents":[{"tag":"TypeConstructor","contents":[["Halogen","Query","EventSource"],"EventSource"]},{"tag":"TypeVar","contents":"m"}]},{"tag":"TypeVar","contents":"a"}]}]}]},null]},null]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":"Constructs an event source from a setup function that operates in `Aff`.\n\n- The `Emitter` that the passed function receives is used to `emit` actions\n  that will be received by the current component, or can be `close`d to\n  shut down the event source and remove the subscription.\n- The `Finalizer` that the passed function produces is there to allow for\n  some clean-up action to be taken when the event source is unsubscribed\n  from. This also runs if the `Emitter` is `close`d. `mempty` can be used\n  here if there is no clean-up to perform.\n"}],"tag":"SearchResult"}]],["afterprint",[{"values":[{"sourceSpan":{"start":[8,1],"name":".spago/web-html/v2.3.0/src/Web/HTML/Event/EventTypes.purs","end":[8,24]},"score":3,"packageInfo":{"values":["web-html"],"tag":"Package"},"name":"afterprint","moduleName":"Web.HTML.Event.EventTypes","info":{"values":[{"type":{"tag":"TypeConstructor","contents":[["Web","Event","Event"],"EventType"]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":null}],"tag":"SearchResult"}]],["afterscriptexecute",[{"values":[{"sourceSpan":{"start":[11,1],"name":".spago/web-html/v2.3.0/src/Web/HTML/Event/EventTypes.purs","end":[11,32]},"score":3,"packageInfo":{"values":["web-html"],"tag":"Package"},"name":"afterscriptexecute","moduleName":"Web.HTML.Event.EventTypes","info":{"values":[{"type":{"tag":"TypeConstructor","contents":[["Web","Event","Event"],"EventType"]}}],"tag":"ValueResult"},"hashAnchor":"v","comments":null}],"tag":"SearchResult"}]]]